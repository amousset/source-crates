<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Pre-RFC: Statically linked external code in Rust crates</title>
  <style>
    html {
      line-height: 1.5;
      font-family: sans;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Pre-RFC: Statically linked external code in Rust crates</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#guide-level-explanation">Guide-level explanation</a></li>
<li><a href="#reference-level-explanation">Reference-level explanation</a></li>
<li><a href="#drawbacks">Drawbacks</a></li>
<li><a href="#rationale-and-alternatives">Rationale and alternatives</a></li>
<li><a href="#prior-art">Prior art</a></li>
<li><a href="#unresolved-questions">Unresolved questions</a></li>
<li><a href="#future-possibilities">Future possibilities</a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#current-state">Current state</a></li>
<li><a href="#perspectives">Perspectives</a></li>
</ul></li>
</ul>
</nav>
<p>https://amousset.github.io/source-crates/ https://rust-lang.github.io/rfcs/2856-project-groups.html</p>
<p>unammed vendoring TODO check cargo vendoring</p>
<ul>
<li>Feature Name: <code>external_source_crates</code></li>
<li>Start Date: 2021-08-08</li>
</ul>
<h1 id="summary">Summary</h1>
<p>One paragraph explanation of the feature.</p>
<h1 id="motivation">Motivation</h1>
<p>Why are we doing this? What use cases does it support? What is the expected outcome?</p>
<h1 id="guide-level-explanation">Guide-level explanation</h1>
<p>Explain the proposal as if it was already included in the language and you were teaching it to another Rust programmer. That generally means:</p>
<ul>
<li>Introducing new named concepts.</li>
<li>Explaining the feature largely in terms of examples.</li>
<li>Explaining how Rust programmers should <em>think</em> about the feature, and how it should impact the way they use Rust. It should explain the impact as concretely as possible.</li>
<li>If applicable, provide sample error messages, deprecation warnings, or migration guidance.</li>
<li>If applicable, describe the differences between teaching this to existing Rust programmers and new Rust programmers.</li>
</ul>
<p>For implementation-oriented RFCs (e.g. for compiler internals), this section should focus on how compiler contributors should think about the change, and give examples of its concrete impact. For policy RFCs, this section should provide an example-driven introduction to the policy, and explain its impact in concrete terms.</p>
<h1 id="reference-level-explanation">Reference-level explanation</h1>
<p>This is the technical portion of the RFC. Explain the design in sufficient detail that:</p>
<ul>
<li>Its interaction with other features is clear.</li>
<li>It is reasonably clear how the feature would be implemented.</li>
<li>Corner cases are dissected by example.</li>
</ul>
<p>The section should return to the examples given in the previous section, and explain more fully how the detailed proposal makes those examples work.</p>
<h1 id="drawbacks">Drawbacks</h1>
<p>Why should we <em>not</em> do this?</p>
<h1 id="rationale-and-alternatives">Rationale and alternatives</h1>
<ul>
<li>Why is this design the best in the space of possible designs?</li>
<li>What other designs have been considered and what is the rationale for not choosing them?</li>
<li>What is the impact of not doing this?</li>
</ul>
<h1 id="prior-art">Prior art</h1>
<p>Discuss prior art, both the good and the bad, in relation to this proposal. A few examples of what this can include are:</p>
<ul>
<li>For language, library, cargo, tools, and compiler proposals: Does this feature exist in other programming languages and what experience have their community had?</li>
<li>For community proposals: Is this done by some other community and what were their experiences with it?</li>
<li>For other teams: What lessons can we learn from what other communities have done here?</li>
<li>Papers: Are there any published papers or great posts that discuss this? If you have some relevant papers to refer to, this can serve as a more detailed theoretical background.</li>
</ul>
<p>This section is intended to encourage you as an author to think about the lessons from other languages, provide readers of your RFC with a fuller picture. If there is no prior art, that is fine - your ideas are interesting to us whether they are brand new or if it is an adaptation from other languages.</p>
<p>Note that while precedent set by other languages is some motivation, it does not on its own motivate an RFC. Please also take into consideration that rust sometimes intentionally diverges from common language features.</p>
<h1 id="unresolved-questions">Unresolved questions</h1>
<ul>
<li>What parts of the design do you expect to resolve through the RFC process before this gets merged?</li>
<li>What parts of the design do you expect to resolve through the implementation of this feature before stabilization?</li>
<li>What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?</li>
</ul>
<h1 id="future-possibilities">Future possibilities</h1>
<p>Think about what the natural extension and evolution of your proposal would be and how it would affect the language and project as a whole in a holistic way. Try to use this section as a tool to more fully consider all possible interactions with the project and language in your proposal. Also consider how this all fits into the roadmap for the project and of the relevant sub-team.</p>
<p>This is also a good place to “dump ideas”, if they are out of scope for the RFC you are writing but otherwise related.</p>
<p>If you have tried and cannot think of any future possibilities, you may simply state that you cannot think of anything.</p>
<p>Note that having something written down in the future-possibilities section is not a reason to accept the current or a future RFC; such notes should be in the section on motivation or rationale in this or subsequent RFCs. The section merely provides additional information.</p>
<p>Case study openssl-src le mieux pour l’instant</p>
<p>etude quantitative et qualitative</p>
<h2 id="introduction">Introduction</h2>
<p>This article investigates the Rust crates including third-party code (often C/C++ libraries) statically linked into Rust binaries. The goal is to explore the current situation and the challenges, and to propose some improvements and proof-of-concepts for dedicated tooling.</p>
<p>There are two main ways to include third-party dependency libraries into a crate source (and resulting binary):</p>
<ul>
<li>dedicated crates (usually containing <code>-src</code> in the name). A widely used example is <code>openssl-src</code> (used as <code>openssl-sys</code> dependency if the <code>vendored</code> feature is enabled).</li>
<li>normal <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html#-sys-packages"><code>-sys</code> crates</a> which are able to compile the library they are providing an interface for, either by default or only when enabled by a feature flag (see this <a href="https://kornel.ski/rust-sys-crate">blog post</a> blog posts for explanations). A widely used example is <code>curl-sys</code>.</li>
</ul>
<p>Sometimes the code is copied into the repository, sometimes it is configured as a git submodule. In any case the source becomes part of the the crate uploaded to the registry.</p>
<h2 id="current-state">Current state</h2>
<p>In order to understand the current situation, besides currently recognizable <code>-src</code> crates, a first step can be to analyze the most downloaded crates, and look for included third-party code.</p>
<h3 id="methodology">Methodology</h3>
<ul>
<li>Select all crates with more than 10k downloads (6984 crates on 2021-05-05)</li>
<li>Try to clone all associated repositories (6322 crates successfully cloned with <a href="https://github.com/amousset/source-crates/blob/main/scripts/clone.sh"><code>scripts/clone.sh</code></a>)</li>
<li>Look for submodules in the cloned crates (595 crates contained submodules)</li>
<li>Then compute information about these crates and their submodules with <a href="https://github.com/amousset/source-crates/blob/main/scripts/modules.py"><code>scripts/modules.py</code></a> in <a href="https://github.com/amousset/source-crates/blob/main/data/crates.json"><code>data/crates.json</code></a>.</li>
</ul>
<p>Among those 595 crates containing submodules, there were 251 different submodule repositories (after excluding submodules in the same Github organization as the source repository). When several crates are hosted in the same directory, the submodule appears several time, which explain the high number of duplicates. The submodules list, with the repositories they are part of, computed with <a href="https://github.com/amousset/source-crates/blob/main/scripts/filter.py"><code>scripts/filter.py</code></a>, is located in <a href="https://github.com/amousset/source-crates/blob/main/data/submodules.json"><code>data/submodules.json</code></a>.</p>
<p><em>Note: Three crates use code from the <a href="https://github.com/copies">copies</a> organization which provides mirrors for projects hosted outside of Github. It gives no indication about who it’s run by, and does not seem to be updated regularly, nor following upstream versions.</em></p>
<p>Among these 251 included repositories:</p>
<ul>
<li>89 contained data sets (unicode data, time zones, syntax highlighting definitions, etc.)</li>
<li>32 contained tests suites or test data set</li>
<li>119 libraries, including 13 Rust libraries, 24 C++ libraries and 71 C libraries</li>
</ul>
<p>(these numbers are based on approximate tagging in <a href="https://github.com/amousset/source-crates/blob/main/data/repositories.toml"><code>data/repositories.toml</code></a>).</p>
<p><strong>In short, there are 95 C/C++ native libraries in the top 7k crates (included with submodules, not counting those directly copied into the crate source.</strong></p>
<p><strong>Only 7 crates including a C/C++ library among these 95 libraries have the <code>-src</code> suffix in their name</strong> (<code>boringssl-src</code>, <code>openblas-src</code>, <code>sqlite3-src</code>, <code>openssl-src</code>, <code>netlib-src</code>, <code>zeromq-src</code> and <code>luajit-src</code>).</p>
<h3 id="conclusions">Conclusions</h3>
<ul>
<li>A lot of widely-used crates include third-party libraries</li>
<li>There is no consistency in naming (crates, features) or behaviors. Some <code>-sys</code> crates (like <a href="https://github.com/alexcrichton/curl-rust/issues/321"><code>curl-sys</code></a>) use statically linked dependencies automatically if not detected on the build system</li>
</ul>
<p>This can be a source of problems, especially because of the lack of visibility over the included code in terms of:</p>
<ul>
<li><em>Presence</em>: It is not always easy to even know if a library was statically linked as it does not appear in the crates tree</li>
<li><em>Licenses</em>: They are often different from the Rust source, and not easily discoverable. For example, <code>cargo deny check licenses</code> cannot check them.</li>
<li><em>Vulnerabilities</em>: Except for dedicated source crates (<code>openssl-src</code> has <a href="https://rustsec.org/packages/openssl-src.html">RustSec advisories</a>), there is no visibility over vulnerabilities affecting the library in the usual Rust tooling (<code>cargo-audit</code> and <code>cargo-deny</code>)</li>
<li><em>Versioning</em>: There is no easy visibility over the upstream version. Sometime the upstream version is used as build version for dedicated crates, like <code>111.15.0+1.1.1k</code> for <code>openssl-src</code> (<code>1.1.1k</code> being the upstream release pointed by the submodule commit)</li>
<li><em>Trust</em>: The code is included from external git repositories, written by unidentified people, and is not visible in tooling like <code>cargo-supply-chain</code>, <code>rust-audit</code> or <code>cargo-crev</code></li>
</ul>
<h2 id="perspectives">Perspectives</h2>
<h3 id="best-practices-for-libraries">Best practices for libraries</h3>
<p>To help the ecosystem converge towards common practices (like it is done for <code>-sys</code> crates), it could be useful to discuss and document them.</p>
<p>They could include (based on existing crates):</p>
<ul>
<li>Recommend to split third-party code inclusion into separate crates, and name them with the <code>-src</code> suffix</li>
<li>Use the upstream version as crate build version</li>
<li>Use git submodules when possible as it makes upstream tracking easier</li>
<li>Use a common behavior for static linking, including feature naming</li>
</ul>
<p>This would allow:</p>
<ul>
<li>To improve discoverability and help library authors who want to allow statically linking a dependency</li>
<li>To know when a static library is included, directly from <code>cargo-tree</code></li>
<li>To file RustSec advisories for vulnerabilities in upstream libraries (like already done for <code>openssl-src</code>). We could automate detection based on CVEs for common libraries, and integrate directly with <code>cargo-audit</code> and <code>cargo-deny</code></li>
</ul>
<h3 id="dedicated-tooling">Dedicated tooling</h3>
<p>Even if all source crates were dedicated and recognizable, important information would still be missing. Before an integrated solution, a solution could be to semi-manually define a database of information about upstream libraries, which could be consumed by the tooling.</p>
<p>This database could include:</p>
<ul>
<li>the library license</li>
<li>the upstream repository (to avoid having to clone to look for submodules)</li>
</ul>
<p>This would allow:</p>
<ul>
<li>To correctly check for licenses in statically linked libraries</li>
<li>To get information about upstream authors in <code>cargo-supply-chain</code></li>
</ul>
<p>A proof-of-concept of such a database is present in <a href="https://github.com/amousset/source-crates/blob/main/db/source-crates.toml">db/source-crates.toml</a>, which contains existing <code>-src</code> crates. The <a href="https://github.com/amousset/source-crates/tree/main/src-crates"><code>src-crates</code></a> cli allows updating its content from crates.io.</p>
<h3 id="proof-of-concept">Proof of concept</h3>
<p>The easiest option for source crates integration would be to be able to use usual tooling of the Rust ecosystem.</p>
<h4 id="cargo-supply-chain"><code>cargo supply-chain</code></h4>
<p>It could be modified to use the information database and display the list of source crates with:</p>
<ul>
<li>License</li>
<li>Version (based on crate version)</li>
<li>Publisher (Github organization in practice for now)</li>
</ul>
<p>Current <a href="https://github.com/amousset/cargo-supply-chain/tree/source_crates">experimental branch</a> gives something like:</p>
<pre><code>$ cargo supply-chain source-crates
Source crates packaging third-party projects:
krb5
  version: 1.18.2
openssl
  license: OpenSSL License/SSLeay
  repository: https://github.com/openssl/openssl
  version: 1.1.1k</code></pre>
<p>It parses upstream version from source crate version and uses information from the source crated database in this repository.</p>
<h4 id="cargo-deny-licenses"><code>cargo deny licenses</code></h4>
<p>The same principle could be done to add static libraries licenses to <code>cargo deny</code> and properly check all included code.</p>
<p>I agree with pretty much everything! That sounds like something I would have done, and I mean that in the best possible way. I believe the problem is real and what you propose is a reasonable solution. I’m not entirely sold on having the license and upstream repo metadata in a third-party repository. I’d rather have it right in the -src crate. I wonder if we can (ab)use the existing Cargo.toml format for that? After all, it is needed for an upload to crates.io regardless, and e.g. openssl-src ships it.</p>
<p>I’m also not convinced that submodules are a good idea. There are a lot of pitfalls around them; for one, a repo with submodules is no longer defined by its commit hash, which makes reproducibility a lot harder. Also, it turns out that C/C++ projects often have different contents in git compared to release tarballs, and require different procedures to build from git vs release tarballs.</p>
<p>I strongly support the -src crate convention, for all the reasons you’ve listed. Automatic detection of CVEs sounds great, and relatively easy to implement.</p>
<p>another thing I’ve lamented is how much e.g. curl versions lag behind upstream, even in case of critical security fixes. We could build automated infrastructure for updating library versions: new release tarballs could be pulled automatically, and with a bit of work even published automatically: we could run crater on the dependencies of the crate before and after the update, if all tests pass then publish it without requiring manual review. I believe @HeroicKatora has been working on a “crater for your dependencies” kind of tool</p>
<p>Hmm, how should the version synchronization between -sys and -src crates be handled? Is there a way to specify “I want -src version X” even though you don’t depend on it directly? If not, should -sys and src crates be published together and always have the same version to allow selecting a specific version of -src crate?</p>
<p>I believe the best way to make progress on this is get a project group going. You can find out more about those here The goals would be something along the lines of creating guidelines for handling externally imported code and developing the supporting tooling (automatic import of new releases, automatic import of CVEs to RustSec, etc) Or, in terms of problems rather than solutions - make it easier to import C/C++ code in a secure and reliable manner and keep it up-to-date</p>
<p>I would be happy to act as the liason for RustSec and cargo-supply-chain, but my availability during the rest of the summer may be spotty.</p>
<p>Oh, putting the upstream version in build metadata (i.e. after +) is not a great idea because according to the semver spec there is no defined ordering for versions that only differ by build metadata. Meaning it might not be possible to match on some build versions but not others, which would be necessary for RustSec. But that’s details.</p>
</body>
</html>
