<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Pre-RFC: Statically linked external code in Rust crates</title>
  <style>
    html {
      line-height: 1.5;
      font-family: sans;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Pre-RFC: Statically linked external code in Rust crates</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#external-source-crates">External source crates</a>
<ul>
<li><a href="#current-state">Current state</a></li>
<li><a href="#issues">Issues</a></li>
<li><a href="#possible-improvements">Possible improvements</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
</ul>
</nav>
<h1 id="external-source-crates">External source crates</h1>
<p>This post investigates the Rust crates including third-party code (often C/C++ libraries) statically linked into Rust binaries. The goal is to explore the current situation and to start a discussion about ways to make it easier to import C/C++ code in a secure and reliable manner.</p>
<h2 id="current-state">Current state</h2>
<h3 id="overview">Overview</h3>
<p>To get an idea to which extent this pattern is used, let’s explore crates.io content with an analysis of the crates with more than 100k downloads on 2022-08-07 (the 4,7k top crates, see the <a href="https://github.com/amousset/source-crates/blob/main/methodology.md">methodology</a> for more details).</p>
<p>There are currently 70 C/C++ native libraries included in 58 crates from the top 4,7k crates (included with submodules, not counting those directly copied into the crate source). Some of them are widely used, like <code>libz-sys</code> with 20M downloads and 46 reverse dependencies, or <code>libgit2-sys</code> with 11M downloads. Among these crates:</p>
<ul>
<li><p>6 have the <code>-src</code> suffix in their name</p>
<ul>
<li><code>boringssl-src</code>, <code>openblas-src</code>, <code>sqlite3-src</code>, <code>openssl-src</code>, <code>zeromq-src</code> and <code>luajit-src</code></li>
<li>A total of 47 crates in crates.io have the <code>-src</code> suffix.</li>
</ul></li>
<li><p>38 are <code>-sys</code> crates that include a library directly</p>
<ul>
<li><code>libevent-sys</code>, <code>pcre2-sys</code>, <code>lmdb-sys</code>, <code>lzma-sys</code>, <code>lmdb-rkv-sys</code>, <code>croaring-sys</code>, <code>openvino-sys</code>, <code>zstd-sys</code>, <code>cloudflare-zlib-sys</code>, <code>mozjpeg-sys</code>, <code>boring-sys</code>, <code>libsodium-sys</code>, <code>librocksdb-sys</code>, <code>libz-sys</code>, <code>libnghttp2-sys</code>, <code>libgit2-sys</code>, <code>sdl2-sys</code>, <code>curl-sys</code>, <code>rpmalloc-sys</code>, <code>sass-sys</code>, <code>rdkafka-sys</code>, <code>snmalloc-sys</code>, <code>wabt-sys</code>, <code>z3-sys</code>, <code>ckb-librocksdb-sys</code>, <code>libssh2-sys</code>, <code>libbpf-sys</code>, <code>oboe-sys</code>, <code>lz4-sys</code>, <code>tikv-jemalloc-sys</code>, <code>fasthash-sys</code>, <code>libusb1-sys</code>, <code>shaderc-sys</code>, <code>minimp3-sys</code>, <code>jemalloc-sys</code>, <code>liblmdb-sys</code>, <code>aom-sys</code>, <code>brotli-sys</code></li>
<li>A total of 2288 crates in crates.io have the <code>-sys</code> suffix.</li>
</ul></li>
<li><p>2 have a <code>_sys</code> suffix, a <code>-sys</code> variant</p>
<ul>
<li><code>audiopus_sys</code> and <code>onig_sys</code></li>
</ul></li>
<li><p>1 has an <code>-ffi</code> suffix, a <code>-sys</code> variant</p>
<ul>
<li><code>wepoll-ffi</code></li>
</ul></li>
<li><p>12 have no specific name pattern</p>
<ul>
<li><code>afl</code>, <code>hidapi</code>, <code>khronos_api</code>, <code>mimalloc</code>, <code>parity-secp256k1</code>, <code>rust-htslib</code>, <code>rusty_v8</code>, <code>souper-ir</code>, <code>spirv-reflect</code>, <code>sprs</code>, <code>tflite</code>, <code>twox-hash</code></li>
</ul></li>
</ul>
<p>Two main patterns appear:</p>
<ul>
<li>standard <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html#-sys-packages"><code>-sys</code> crates</a> which are also able to compile the library they are providing an interface for, either by default or only when enabled by a feature flag (see this <a href="https://kornel.ski/rust-sys-crate">blog post</a> for details on how it’s done).</li>
<li>dedicated crates containing <code>-src</code> in the name, depended on by <code>-sys</code> crates</li>
</ul>
<p><em>Note</em>: This only covers the crates containing submodules, but sometimes the code is vendored directly into the repository, like <code>freetype-sys</code> which has a copy of freetype2 sources. In any case, the source becomes part of the crate uploaded to the registry.</p>
<h3 id="case-studies">Case studies</h3>
<p>Let’s have a closer looks at a few representative crates.</p>
<h4 id="mozjpeg-sys">mozjpeg-sys</h4>
<ul>
<li>The source is included through a git submodule.</li>
<li>The version number of the crate, <code>1.0.2</code>, is not related to the upstream version, <code>4.0.3</code>.</li>
<li>The license of the crate is <code>IJG</code> which broadly matches the source crate (but seems <a href="https://github.com/mozilla/mozjpeg/blob/5c6a0f0971edf1ed3cf318d7b32308754305ac9a/LICENSE.md">incomplete</a>)</li>
<li>It always builds <code>mozjpeg</code> as a static dependency.</li>
</ul>
<h4 id="curl-sys">curl-sys</h4>
<ul>
<li>The source is included through a git submodule.</li>
<li>The crate versions are built as the following SemVer string: <code>0.4.56+curl-7.83.1</code>, defined as <code>MAJOR.MINOR.PATCH+BUILD</code> with <code>BUILD</code> being <code>curl-</code>+the upstream curl version.</li>
<li>By default, it will try to dynamically link to the system curl and openssl, and fallback on static linking. It also has <code>static-curl</code>/<code>static-ssl</code> features to enforce static linking.</li>
<li>There is <a href="https://github.com/alexcrichton/curl-rust/issues/321">no way</a> to enforce dynamic linking (i.e. make the build fail if library is missing on the system).</li>
<li>The crate documents an <code>MIT</code> license, while curl is licensed under a custom license (but close to MIT).</li>
</ul>
<h4 id="openssl-src">openssl-src</h4>
<ul>
<li>The source is included through a git submodule.</li>
<li>The crate only contains the logic to build openssl. The API is in <code>openssl-sys</code> which depends on <code>openssl-src</code> when the <code>vendored</code> feature is enabled (disabled by default). Some crates depending on <code>openssl-sys</code> (like <code>openssl</code> and <code>native-tls</code>) expose a similar flag too.</li>
<li>The crate documents an <code>MIT OR Apache-2.0</code> license, while openssl is licensed under:
<ul>
<li>Apache-2.0 starting from 3.0</li>
<li>Dual OpenSSL and SSLeay licenses before, which are in particular not compatible with the GPL. The <code>release/111</code> branch providing versions under this license is still maintained.</li>
</ul></li>
<li>The crate versions are built as the following SemVer string: <code>111.16.0+1.1.1l</code>, defined as <code>MAJOR.MINOR.PATCH+BUILD</code>, with <code>BUILD</code> being the upstream openssl version.</li>
</ul>
<h2 id="issues">Issues</h2>
<p>A lot of widely-used crates include third-party libraries, with little consistency. It causes problems in terms of:</p>
<ul>
<li><em>Visibility</em>: It is not always easy to know if a library was statically linked (and which version) as it does not appear in the crates tree, <code>cargo-auditable</code> data, or any automated <a href="https://www.cisa.gov/sbom">SBOM</a> (like <a href="https://github.com/alilleybrinker/cargo-spdx">cargo-spdx</a>)</li>
<li><em>Usability</em>: The way to select static vs. dynamic compilation varies, and is sometimes not even actionnable. Some <code>-sys</code> crates fall back to using statically linked dependencies if not detected on the build system <a href="https://github.com/alexcrichton/curl-rust/issues/321">without a way to force dynamic linking</a>.</li>
<li><em>Licenses</em>: The core problem here is that the license documented in the <code>Cargo.toml</code> (which is supposedly thought to cover only the build code) is sometimes different from the licenses applicable to the library itself, meaning the crate metadata does not match reality. In this case they are not easily discoverable, and tools like <code>cargo deny check licenses</code> cannot check them. A good example is the OpenSSL licence for versions before 3.0, which is incompatible with GPL.</li>
<li><em>Vulnerabilities</em>: Except for <a href="https://rustsec.org/packages/openssl-src.html">dedicated source crates</a>, there is no accurate visibility over vulnerabilities affecting the included library in the usual Rust tooling (<code>cargo-audit</code> and <code>cargo-deny</code>).</li>
<li><em>Trust</em>: The code is included from external sources, written by unidentified people, and is not visible in tooling like <code>cargo-supply-chain</code>, <code>rust-audit</code> or <code>cargo-crev</code></li>
</ul>
<h2 id="possible-improvements">Possible improvements</h2>
<p>Just like <code>-sys</code> crates have an official definition in cargo docs, with a set of recommended practices, a first step could be to come up with similar guidelines for external source crates. This could build upon implementations, and allow an easy convergence for libraries using different patterns. This could then be improved by additional tooling or metadata.</p>
<h3 id="crate-architecture">Crate architecture</h3>
<p>Having dedicated crates (with the <code>-src</code> suffix for discoverability) seems to have quite a few advantages:</p>
<ul>
<li>Allow independent versioning, releases, licenses, security advisories</li>
<li>Give visibility over included code in all cargo-based tooling</li>
</ul>
<p>One obvious big drawback is the maintenance overhead.</p>
<h4 id="configuration">Configuration</h4>
<p>Ideally there should be a recommended way (through features on <code>-sys</code> crates) to:</p>
<ul>
<li>Allow to enforce either static or dynamic linking</li>
<li>Keep the convenient default used in most existing crates (dynamic linking with static fallback)</li>
</ul>
<p>The is already a <a href="https://internals.rust-lang.org/t/pre-rfc-cargo-features-for-configuring-sys-crates/12431">pre-RFC</a> by @kornel to discuss this.</p>
<h3 id="source-embedding">Source embedding</h3>
<p>There are two ways:</p>
<ul>
<li><p>git submodule</p>
<ul>
<li>Some libraries have different contents in git compared to release tarballs, and may have different build procedures (git vs. tarball).</li>
</ul></li>
<li><p>Source import in tree</p></li>
</ul>
<h3 id="versioning">Versioning</h3>
<p>Most existing <code>-src</code> crates use the SemVer build metadata to provide upstream version. Build metadata is <a href="https://semver.org/#spec-item-10">defined</a> as a <em>series of dot separated identifiers using only ASCII alphanumerics and hyphens</em>, which are <em>ignored when determining version precedence</em>. Hence, the format is quite flexible, but cannot be used for actual versioning.</p>
<p>Using the upstream version directly as the crate version would cause some trouble:</p>
<ul>
<li>Not all software use SemVer compatible versioning</li>
<li>We need to keep a way to publish updated build code without bumping the embedded code</li>
</ul>
<h3 id="metadata">Metadata</h3>
<p>The license of a crate should probably cover all files included in the crate (and produced binaries), including external embedded files.</p>
<h3 id="improve-tooling">Improve tooling</h3>
<p>Some cargo-based tooling could get some knowledge to detect <code>-src</code> crates and implement special handling (extract upstream version, etc.), maybe using additional metadata (external source, etc.).</p>
<h2 id="conclusion">Conclusion</h2>
<ul>
<li>Do you know other ressources around this topic?</li>
<li>If others are interested, a <a href="https://rust-lang.github.io/rfcs/2856-project-groups.html">project group</a> could be created to work on this topic.</li>
</ul>
<p><em>Special thanks to @Shnatsel for reviewing this.</em></p>
</body>
</html>
